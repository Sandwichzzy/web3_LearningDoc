### 1. 首先，理解普通的Merkle树

想象一下，你有8个数据块（比如交易记录）。为了确保这些数据没有被篡改，你构建了一棵树：

- **叶子节点**：在最底层，每个数据块都经过哈希计算，得到一个哈希值（就像它的数字指纹）。
- **父节点**：每两个相邻的叶子节点的哈希值拼接在一起，再计算一次哈希，得到它们父节点的哈希值。
- **重复这个过程**：继续向上，每两个相邻的父节点哈希再拼接、再哈希，直到树顶，得到一个最终的根哈希。

这个根哈希就像是整个数据集的“唯一摘要”。只要任何一个数据块被修改，根哈希就会彻底改变。

**普通Merkle树的问题**：如果你想证明“某个数据块**不存在**”于这个集合中，是非常困难的。你几乎需要展示所有数据来证明它真的不在里面。

------

### 2. 稀疏Merkle树是什么？

稀疏Merkle树解决了“证明不存在”的问题。

**核心思想：** 它是一棵巨大的、预先建好的“空树”。

- **巨大的地址空间**：想象这棵树有2²⁵⁶个叶子节点！这个数量远远超过宇宙中的原子数。每个叶子节点都有一个唯一的“地址”（从0到2²⁵⁶-1）。
- **初始状态为空**：在最开始，整棵树都是空的。每一个叶子节点都被赋予了一个默认的“空值”的哈希（比如全为0的哈希）。
- **“稀疏”的含义**：因为地址空间巨大，而实际存储的数据很少（比如只有几个数据块），所以这棵树的绝大多数叶子节点都是空的，只有极少数叶子有数据。这就是“稀疏”的由来。

------

### 3. 稀疏Merkle树是如何实现的？

我们一步步来看它的操作逻辑。

#### 步骤一：确定数据的位置

在稀疏Merkle树中，一个数据存放在哪个叶子节点，不是由顺序决定的，而是由它的 **“键”** 决定的。

- 比如，你的数据键是 `Alice`。我们通过一个哈希函数（如SHA-256）把 `Alice` 映射到一个256位的二进制数，比如 `0101...110`。
- 这个256位的二进制数，就是 `Alice` 这个数据在巨大树中的**地址**。它指明了从树根到叶子需要走的路径（0向左，1向右）。

#### 步骤二：插入和更新树

现在我们要把 `Alice` 的数据存入树中。

1. **定位叶子**：根据 `Alice` 的哈希地址，我们沿着路径（比如 0->1->0->1...）一路找到对应的那个叶子节点。
2. **更新叶子**：将这个空叶子节点更新为 `Alice` 数据的哈希值。
3. **向上递归更新**：由于这个叶子节点的哈希值变了，它的父节点、祖父节点……一直到树根的哈希值，都需要沿着刚才的路径**重新计算**。
4. **最终**：你得到了一个新的根哈希，它代表了包含 `Alice` 数据后的整个树的状态。

**关键点**：即使树中只有 `Alice` 一个数据，整棵树的根哈希也是基于所有2²⁵⁶个叶子节点（其中绝大多数是空节点）计算出来的。

#### 步骤三：如何实现高效存储和计算？

你可能会想：“存储一棵有2²⁵⁶个节点的树？这根本不可能！”

确实如此。所以实现上使用了**优化技巧**，核心是 **“懒计算”** 和 **“节点共享”**。

- **默认哈希**：我们预先知道，所有空叶子节点的哈希都是 `H_zero`（比如全0）。
- **空子树的根哈希**：我们也可以预先计算出一棵完全为空的大树的根哈希是多少。实际上，每一棵空子树（无论多大）的根哈希都可以被预先计算并缓存起来。
- **实际存储**：我们只存储和计算那些因为插入了数据而**发生改变的节点路径**。其余的绝大部分节点，我们都不需要实际存储，因为我们知道它们就是默认的空哈希。

**比喻**：
想象一片巨大的空白方格纸（代表空树）。当你只在其中一个格子里点了一个黑点（插入数据），你只需要记录下这个黑点的位置和它影响的极少数线条。整张纸的其他部分，你知道它们都是白色的，不需要一一描述。

#### 步骤四：成员证明 vs. 非成员证明

这是稀疏Merkle树的杀手级应用。

- **成员证明**：证明 `Alice` 的数据存在。
  - 和普通Merkle树一样，提供一条从 `Alice` 的叶子节点到树根的“认证路径”（即路径上所有兄弟节点的哈希值）。验证者可以通过计算验证这条路径最终能否得到正确的根哈希。
- **非成员证明**：证明 `Bob` 的数据**不存在**。
  1. 根据 `Bob` 的键找到它本应存在的叶子节点。
  2. 提供通往这个叶子节点的认证路径。
  3. 如果这个路径的末端（即 `Bob` 的叶子节点）的哈希值是**默认的空值哈希**（`H_zero`），那么就铁证如山地证明了 `Bob` 的数据不存在于这棵树中。

------

### 总结与优势

**稀疏Merkle树是什么？**
它是一个拥有巨大、固定数量叶子节点的Merkle树，其中绝大部分叶子为空，并填充默认值。数据通过其键的哈希值被定位到特定的叶子节点上。

**它是如何实现的？**

1. 定义一个巨大的地址空间（如2²⁵⁶）和一套默认的空哈希值。
2. 通过数据的键确定其在树中的唯一路径。
3. 只创建和更新被数据影响的路径上的节点，其余部分用预计算的空哈希代替，从而实现高效存储和计算。
4. 利用从叶子到根路径上的兄弟节点哈希值，可以同时提供**存在性**和**非存在性**证明。

**核心优势：**

- **高效的非成员证明**：这是它最主要的价值。
- **计算的连续性**：树的形态是固定的，只有叶子节点的值在变。这使得计算增量更新（比如从状态A到状态B的根哈希变化）非常高效。

**典型应用：**
在区块链中，用于存储整个系统的状态（比如每个账户的余额），当一个新节点加入时，你可以快速向它证明某个账户不存在，而不需要下载整个历史记录。



### 4. MPT 与 “经典”稀疏Merkle树的联系

为什么说 MPT 和稀疏Merkle树有联系呢？因为它们要解决的核心问题是相同的：**如何高效地、可验证地存储一个巨大的、稀疏的键值对集合。**

- **键**：以太坊账户的地址（20字节）。
- **值**：账户的余额、Nonce、代码哈希、存储根等。
- **稀疏性**：地址空间是 2¹⁶⁰，这是一个天文数字，但实际存在的活跃账户数量相对极少。所以这是一个典型的稀疏数据集。

“经典”的稀疏Merkle树（我们之前讨论的那种）会使用一个完整的二进制树，并利用默认哈希来优化空节点。而 MPT 采用了一种不同的、更显式的优化策略。

### 5. MPT 是如何实现“稀疏”和优化的？

MPT 没有使用固定的二进制深度和默认哈希，而是通过其节点类型来动态地、紧凑地表示这棵稀疏的树：

1. **空节点**：直接表示一个空。
2. **分支节点**：一个拥有17个元素的数组（[0...f] + 一个value）。用于处理键在某个节点处开始分叉的情况。
3. **扩展节点**：用于“压缩”路径。当一个节点只有一个子节点时，使用扩展节点将多个连续的单路径节点合并成一个，存储 `[共享前缀, 下一个节点的指针]`。这极大地缩短了树的深度和寻径时间。
4. **叶子节点**：存储最终的数据。形式为 `[键的剩余部分, 值]`。

**通过这种设计，MPT 实现了与稀疏Merkle树相似的目标，但方式不同：**

| 特性           | 经典稀疏Merkle树                               | 以太坊的 MPT                                                 |
| :------------- | :--------------------------------------------- | :----------------------------------------------------------- |
| **非成员证明** | 通过提供一条以**默认空哈希**结尾的路径来证明。 | 通过提供一条**路径不存在**的证明来证明。例如，路径指向一个空节点，或者路径中的一个分支节点在关键位置没有子节点。 |
| **效率优化**   | 依赖于计算和缓存大量**默认哈希**。             | 依赖于**路径压缩** 和显式的节点类型，避免遍历不必要的深度。  |
| **结构**       | **固定的、完整的**二叉树结构。                 | **动态的、不规则的**树结构，形状取决于存储的数据。           |
| **键处理**     | 键的整个哈希值直接决定了从根到叶的完整路径。   | 键的哈希（或原始地址）被逐个半字节地                         |





