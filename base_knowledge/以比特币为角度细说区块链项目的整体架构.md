# （七）. 以比特币为角度细说区块链项目的整体架构

## 一. 内容提要

- 比特币的基本介绍
- Bitcoin 的数据结构
- Bitcoin 共识算法
- Bitcoin 挖矿相关概念
- UTXO 模型
- 比特地址，版本迭代过程
- 比特币的脚本编程
- Taproot 升级
- 比特生态的项目



## 二. Bitcoin 基本介绍

08 年的金融危机，中心金融，美元崩塌会导致全球经济崩溃，全球的国家为美国的经济买单；比特币全球流通性，资产去中心化发行，强调去中心化性和全球性，不会因为局部经济崩塌而崩溃，比特币崩溃全球经济才会崩溃；数字来取代传统金融，提高资产主权和全球性经济问题。

比特币是第一个区块项目，也是目前为止去中心化程度最高，市值，受欢迎程度最高公链和数字货币，甚至已经成为全球各国央行的储备货币。

Bitccoin **具备银行功能**

- 银行的资产发行在比特币是怎么做，比特币通过 POW 来挖矿铸币
- Bitcoin 通过侧链/BRC20/铭文/符文协议，发行数字货币

Bitcoin **具备法币的属性**

- 法币具备支付功能，比特币也是具备支付功能
- 法币具备投资，比特币也具备投资

Bitcoin **具备法币不具备的功能**，有自己的特性

- **去中心化属性**，银行发行代币，去中心，只有银行自己可以发行；比特币是去中心化，任何参与比特挖矿人都可以获得比特币
- **不可篡改**
- 法币可以无限发行，比特币是不可以无限发行，它是由上限，上限 2100 万枚
- **可追溯性**，任何都可以追溯比特代币发行，交易等，但是银行不具备可追溯性

Bitcoin 比起**中心化的金融机构**，比特币更强调

- **价值主权/资产主权**： 资产控制在掌握私钥的人手里面
- **数据主权**：比特币具备隐私性，没有和 KYC，钱包地址并没有和人进行绑定，资产无法对应实体，更强调隐私属性，UTXO 和 schnnor 使得比特币的隐私性更强
- **全球流通性**：比特币强调全球流通性； 美元，人民币，泰铢更多的是本地流通性
- **金融效率**问题：拿着在美国可以花费，在中国可以花费，拿着泰铢只能泰国消费，来中国肯定需要换成人民币。

## 三. Bitcoin 的数据结构

### 1. Bitcoin 的基本的区块结构

![区块链基本结构](imgs/区块链基本结构.png)

- Genesis Block: 创始块，链启动的时候生成的第一个块

![区块链基础结构](imgs/区块链基础结构.png)

### 2. 区块的产生流程

![区块的产生流程](imgs/区块的产生流程.png)

### 3. 比特币解决区块分叉的问题

![比特币解决分叉](imgs/比特币解决分叉.png)

- 比特币遵循最长链原则，短的链会被丢弃，分叉的区块是没有奖励的

### 4. 确认位

![比特币确认位](imgs/比特币确认位.png)

## 四. Bitcoin 的共识算法

POW 挖矿流程

- 找 nonce, 满足 Hash(nonce,  data) < target, 率先找到满足条件的 nonce 节点具备出块的权利
- 找到满足条件的 nonce 之后呢，立即生成该区块并广播给其他节点
- 打包区块的节点会获得奖励
  - 打包的奖励（挖矿奖励），每一区块里面第一笔就是挖矿奖励（coinbase 交易）
  - 区块里面的交易手续费奖励

找 nonce, 满足 Hash(nonce,  data) < target

- target: 挖矿的目标值，越小代表挖矿难度越大
- Hash 算法是一个 Sha256 算法

挖矿难度问题

- 每过 2016 个块，会进行一次难度调整，按照每 10 分钟出一个块的话，每次调整大约是两周

- new_target = old_target * (actual_time / target_time)

  new_difficulty = target_before  /  new_target

- 出块时间控制在 10 分钟左右，保证区块不会发生分叉丢失

Bitcoin 的总量 2100 万枚，每隔 21 万个块会发生一次减半

- 50
- 50 / 2
- 50 / 4
- 50 / 8
- 50 / n

减半的公式：50 (1/2 + 1/4 + 1/8 + ... + 1/n) = 2100万



## 五. Bitcoin 挖矿相关的概念

- 节点
  - 全节点：拥有全量的数据的节点
  - 轻节点：区块头的数据
- 矿工：去找出 nonce 值得出 hash(nonce + data) < target
- 矿池：所有的矿工节点组成的一个集合
- 矿机：专用于 Bitcoin 的挖矿机器， 专用 CPU 或者 GPU 



## 六. UTXO账户模型

当矿工/或者普通持有比特币，他们需要去转帐，把钱转给别人，接收别人转钱给他，在传统银行里面，也有转账的整个操作。

- 传统银行
  - Source: 出资账户
  - Dest: 接收资金账户
  - Amount: 转账的金额
  - Fee: 转账银行要收取手续费, 也有可能 0 收费转账
- 在区块世界里面，有两种模式，一种和传统银行是类似（账户模型，eth），另一个是和传统银行模式完全不一致（UTXO）

我们**比特币**使用模式和传统银行完全不一样，**使用 UTXO**；

UTXO（为花费的输入输出）： A 向用户 B 转账

- **A 以前的未花费输出（UTXO）**：假设 A 有 3 个未花费输出，总余额为 1.4 BTC：

  - UTXO-1: 0.1 BTC
  - UTXO-2: 0.9 BTC
  - UTXO-3: 0.5 BTC

- **A 向 B 转账 1 BTC**，并支付手续费 0.1 BTC。

  - 总输入：0.1 + 0.9 + 0.5 = 1.4 BTC
  - 总输出：给 B 的 1 BTC + 找零给 A 的金额
  - 手续费：0.1 BTC（由输入输出差决定）

- **交易过程**：

  - A 需要消耗所有三个 UTXO 作为输入（因为单个 UTXO 可能不足，或者为了整合资金）。
  - 输出包括：
    - 给 B 的输出：1 BTC（这是一个新的 UTXO，归属 B 的地址）
    - 找零给 A 的输出：0.3 BTC（这是一个新的 UTXO，归属 A 的地址）
  - 手续费计算：输入总和 (1.4 BTC) - 输出总和 (1 BTC + 0.3 BTC) = 0.1 BTC，这笔手续费会被矿工在打包交易时获取。

- **交易完成后**：

  - B 地址有一个新的 UTXO，价值 1 BTC。
  - A 地址有一个新的 UTXO，价值 0.3 BTC（找零）。
  - 矿工获得了 0.1 BTC 的手续费。

  | 交易输入 (Inputs)                       | 交易输出 (Outputs)               |
  | :-------------------------------------- | :------------------------------- |
  | Input-1: 0.1 BTC (来自 A)               | Output1: 1 BTC (到 B 地址)       |
  | Input-2: 0.9 BTC (来自 A)               | Output2: 0.3 BTC (找零到 A 地址) |
  | Input-3: 0.5 BTC (来自 A)               |                                  |
  | **输入总和: 1.4 BTC**                   | **输出总和: 1.3 BTC**            |
  | **手续费: 0.1 BTC** (1.4 BTC - 1.3 BTC) |                                  |

- UTXO 过程图解

![utxo](imgs/utxo.png)

**转账的过程**

- Input 是收入，没有花费掉的
- Output 输出，是已经花费掉了
- 在比特币里面可以多对一，一对多，多对多的转账模式
- 当一个地址上有多个 Input 的时候，可以选择消费其中的任意一个或者任意几个，或者全部都可以
- 对于一个地址来说，所有的 input 的金额加起来减去所有的 output 加起来的值就是该地址的余额

**实际交易截图**

![btc交易截图](imgs/btc交易截图.png)

![btc交易截图2](imgs/btc交易截图2.png)

## 七. 比特币的版本迭代过程

### 1. 版本迭代

比特币自 2009 年发布以来，经历了多次重要升级。这些升级旨在提高比特币网络的安全性、效率和功能性。

并且比特币的 Taproot 升级给比特币带来更多的可能性，Taproot 升级带动了 BRC20 和 Bitcoin-Layer2 的发展，这里我们不再做过多的介绍，在未来的 Layer2. 的课程中我们会深入讲解这部分的内容

**P2SH（Pay-to-Script-Hash）**

💡💡时间：2012年

💡💡BIP（Bitcoin Improvement Proposal）：BIP-0016

💡💡内容：允许更复杂的交易脚本，**支持多重签名地址**。这种升级使得比特币交易更加灵活和安全

**比特币改进提案 BIP 66**

💡💡时间：2015年

💡💡BIP：BIP-0066

💡💡内容：规范了交易中 DER 格式的签名，解决了**交易签名的一致性**问题，增强了网络的安全性。

**CheckSequenceVerify（CSV）**

💡💡时间：2016年

💡💡BIP：BIP-0112

💡💡内容：**增加了相对时间锁功能**，使得交易可以在指定的时间或块高度之后才生效，这为更复杂的支付通道铺平了道路。

**Segregated Witness（SegWit）**

💡💡时间：2017年

💡💡BIP：BIP-0141, BIP-0143, BIP-0144

💡💡内容：**分离交易签名数据**，**提高了区块的有效容量**，减小了交易体积，降低了交易费用。还解决了交易的可塑性问题，**使得闪电网络等侧链解决方案**成为可能。

**隔离见证2x（SegWit2x）**

💡💡时间：2017年

💡💡内容：这次升级是对 SegWit 的后续提案，旨在进一步增加区块大小。然而，由于社区共识未达成，这次升级最终未能实现。

**Taproot**

💡💡时间：2021年

💡💡BIP：BIP-0340, BIP-0341, BIP-0342

💡💡内容：引入了 **Schnorr 签名和默克尔化抽象语法树**（MAST），**增强了隐私性和执行脚本验证**的功能，进一步提高了交易的灵活性和效率。这是自2017年 SegWit 以来**最重要的一次升级**。

**（1）MAST（Merkelized Abstract Syntax Trees）**

💡💡时间：2021年

💡💡BIP：作为 Taproot 的一部分

💡💡内容：**允许将多种条件的智能合约合并为一个**，使得只有满足条件的部分才被公开，**提高了隐私性和效率**。

**（2）Schnorr Signatures**

💡💡时间：2021年

💡💡BIP：作为 Taproot 的一部分

💡💡内容：提供了一种更高效和安全的签名算法，**允许多重签名聚合**，提高了**交易的隐私性**和可扩展性



### 2. 地址格式

Bitcoin 钱包地址有几种不同的类型，每种类型都有其特定的用途和特点。主要的几种类型包括：

- P2PKH（Pay-to-PubKeyHash）地址：

  - 格式：以 1 开头，例如，1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa。
  - 特点：这是最传统和最常见的地址类型，广泛用于比特币的早期交易。
  - 优点：兼容性好，几乎所有钱包和交易所都支持。
  - 缺点：随着时间的推移，这种地址类型的使用效率较低，交易费用可能会较高。

- P2SH（Pay-to-Script-Hash）地址：

  - 格式：以 3 开头，例如，3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy。
  - 特点：这种地址允许更复杂的交易脚本，例如多重签名地址。
  - 优点：支持更复杂的交易和脚本，安全性更高。
  - 缺点：创建和管理比 P2PKH 地址更复杂。

- Bech32（SegWit）地址：

  - 格式：以 bc1 开头，例如，bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwfvenl。
  - 特点：这是比特币改进提案BIP-0173中引入的新地址格式，旨在提高交易效率和减少费用。
  - 优点：交易费用更低，处理速度更快，且有助于减少交易体积。
  - 缺点：并非所有的钱包和交易所都支持这种地址类型，尽管支持率在逐步增加。

- Bech32m

  - 格式：P2TR（Pay-to-Taproot）和使用 Bech32m 编码。P2TR 地址以“bc1p”开头

  - 特点

    - Bech32m 是基于比特币改进提案（BIP-350）设计的，主要用于生成更具鲁棒性的地址。**它将地址表示为一串以字母和数字组成的字符串**（不区分大小写），确保不会出现混淆字符。
    -  与 Bech32 的区别在于校验和的算法不同，Bech32m 使用了新的校验和常数 `0x2bc830a3`，这一改动提高了校验的准确性，并且能够避免常见的人为错误。
    - Bech32m 主要用于 Taproot 升级，为比特币未来的扩展性而设计。

  - 优点：

    - Bech32m 格式非常注重防止用户在手动输入地址时的复制和输入错误。通过精确的校验和设计，能够高效地检测和纠正错误输入
    - Bech32m 编码不区分大小写，避免了用户在输入地址时因为大小写混淆而犯错误，提升了使用体验。
    - Bech32m 使用了一种简洁、易于理解的格式，长度相对固定，使用的字符集限制在 32 个字符，避免了难以区分的字符（如 1 和 l、0 和 O），使得地址较为直观。
    - Bech32m 可以检测单个字符的错误和交换错误，进一步减少手动输入地址的风险。

  - 缺点：平台兼容性问题

    

    每种地址类型都有其特定的应用场景和优缺点，用户可以根据自己的需求选择合适的地址类型来存储和交易比特币



## 八. 比特币的脚本编程

比特币脚本编程是比特币区块链的核心组成部分，它定义了如何验证和执行比特币交易。比特币的脚本是一种基于堆栈的编程语言，用来处理比特币的交易验证逻辑。比特币脚本的编写和使用并不像智能合约那样复杂，它主要用于验证交易的合法性，而不是执行复杂的程序逻辑。

以下是比特币脚本编程的一些基本概念和特点：

### **1. 堆栈式语言**

比特币脚本使用堆栈（stack）来进行操作。每个操作码（opcode）会从堆栈中获取输入，然后对其进行处理，并将结果放回堆栈中。堆栈语言是一种后缀表达式语言，执行顺序是按照指令顺序来进行。

### **2. 图灵不完备**

比特币脚本并不是图灵完备的编程语言。这意味着它不能执行循环或递归，目的是确保脚本的执行是确定且有限的，从而避免像以太坊那样需要“Gas”机制来防止无限循环。

### **3. 脚本结构**

比特币交易脚本一般分为两个部分：

- **锁定脚本（ScriptPubKey）**：规定接收方要花费比特币时需要满足的条件。
- **解锁脚本（ScriptSig）**：由花费者提供，证明他们有权花费这个比特币，通常是一个签名和公钥。

当一个比特币交易被广播时，比特币客户端会先执行解锁脚本，然后执行锁定脚本。如果整个执行流程成功且堆栈顶端有一个 `True` 值，那么交易被认为是合法的。

### **4. 常见操作码**

比特币脚本包含一系列操作码，常见的操作码包括：

- **OP_DUP**：复制栈顶的元素。
- **OP_HASH160**：对栈顶的元素进行哈希操作。
- **OP_EQUALVERIFY**：验证两个栈顶元素是否相等。
- **OP_CHECKSIG**：检查提供的签名是否有效。

### **5. 脚本的应用**

- **P2PKH（Pay-to-PubKey-Hash）**：最常见的交易类型，要求提供公钥和签名以解锁比特币。
- **P2SH（Pay-to-Script-Hash）**：允许使用复杂的自定义脚本，交易的条件由锁定脚本来定义。
- **多重签名（Multisig）**：需要多个签名来共同花费比特币，通常用于共享控制钱包。

### **6. 示例**

以下是一个典型的 P2PKH 脚本示例：

**锁定脚本（ScriptPubKey）**：

- `OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
  - `OP_DUP`：复制栈顶的公钥。
  - `OP_HASH160`：对公钥进行哈希，得到公钥的哈希值。
  - `<PubKeyHash>`：预期的公钥哈希值。
  - `OP_EQUALVERIFY`：验证两个哈希值是否相等。
  - `OP_CHECKSIG`：检查签名是否有效。

**解锁脚本（ScriptSig）**：

- `<Signature> <PublicKey>`
  - 提供解锁这个比特币所需的签名和公钥。

比特币脚本是强大的工具，但由于其有限的表达能力，它主要用于交易验证和基本的多签名机制。想要编写更复杂的逻辑，通常需要借助二层协议或其他区块链平台。



## 九.Taproot 的升级（后面钱包会细讲,大概了解下）

###  1. Taproot 升级的主要内容

- Schnorr 签名(BIP 340)、Taproot (BIP 341)和TapScript (BIP 342): 
  - schnorr 签名在专利期，减小交易体，使得交易具备一定隐私性（schnorr 签名底层有类似零知识证明的相关东西）
  -  Merkel 抽象语法树(MAST)：使得 Bitcoin 具备一些智能合约相关功能，可以对简单数据进行验证

### 2. Taproot 概述

比特币改进提案（BIPs）是为比特币引入新功能和信息的设计文档，而 Taproot 升级则是三个 BIPs 的汇编，这三个 BIPs 分别是 Schnorr 签名(BIP 340)、Taproot (BIP 341) 和 TapScript (BIP 342)，这三个升级统称为 BIP Taproot，它将为比特币带来了更高效、更灵活、更私密的传输方式，其核心在于使用了 **Schnorr 签名**和 **Merkel 抽象语法树**(MAST)。

![MAST](imgs/MAST.png)

Taproot的原理，简单来说，就是定义了一种输出和两种花费路径。如上图所示，有Alice和Bob两个参与者，Taproot的运作过程如下:

- 将Alice和Bob的公钥聚合为： C=P_A+P_B
- 加入MerkleRoot，公钥聚合为：P=C+H(C||MerkleRoot)G，其中 H(C||MerkleRoot) 表示C和MerkleRoot的组合hash
- 锁定脚本中填入聚合公钥P，格式类似Segwit：`[ver] [P]`。ver表示版本号，Taproot中ver=1。
- 花费路径有两个，二选一：
  - 签名模式：Alice和Bob全部签名产生聚合签名，填入见证脚本。利用聚合公钥P,对签名进行验证后即可花费。
  - 脚本模式：Alice和Bob，有一个拒绝签名，可以走脚本模式。此时Alice想要完成花费，那么见证脚本中需要填入：`符合Script 1的执行数据D, Script 1, C, Hash 2 `。为了验证签名，首先利用`Script 1, Hash2`，计算MerkleRoot，然后验证 P==C+H(C||MerkleRoot)G 是否成立，最后构建完整脚本`D||Script 1`并执行脚本，验证结果是否为真。当上述验证通过后，即可完成花费。

Taproot按照签名模式进行花费时，多个参与方和单个参与方在区块链上看起来都长得是一样的，所以许多区块链分析将不可用，从而为所有 Taproot 用户保留隐私。与此同时，Taproot的脚本花费模式让用户可以实现复杂的支出条件。Taproot可以有效压缩交易脚本字节数。签名模式下随着参与者增加，EDSA交易脚本大小线性增长，Taproot交易脚本大小保持不变。脚本模式下随着脚本数量的增加，EDSA交易脚本大小线性增长，Taproot交易脚本大小对数增长。

#### **2.1 Huffman Tree**

 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

![huffmanTree](imgs/huffmanTree.png)



哈夫曼树的构造过程是利用贪心的思想，每次选择权重最小的两个结点组合成新的节点，加入到原始集合，重复上述过程，直至结束。如上图所示，存在权重集合为 (1, 2, 3, 4, 5)  的5个结点，构造哈夫曼树的过程如下：

- 从集合中选择权重最小的 1, 2 结点，组合成权重为3的结点，集合变成 (3,3,4,5)
- 从集合中选择权重最小的 3, 3 结点，组合成权重为6的结点，集合变成 (4, 5, 6)
- 从集合中选择权重最小的 4, 5 结点，组合成权重为9的结点，集合变成 (6, 9)
- 从集合中选择权重最小的 6, 9 结点，组合成权重为15的结点，集合变成 (15) , 构造过程结束

可以看出，在哈夫曼树中，权重越大的结点离根越近，权重越小的结点离根越远。



#### **2.2 Huffman Tree在Taproot的应用**

Taproot相比于ECDSA多签算法，一大优势是Schnorr聚合签名可以将多个签名数据压缩合并成单个聚合签名。使用聚合签名技术后，交易脚本的字节数大大减少，可以有效减少交易费用的支出。当我们按照脚本模式进行花费时，借助MAST的树形结构，交易脚本大小随着脚本数量对数增长。然而利用Huffman Tree，可以通过改进MAST的构造过程，帮助我们进一步减少脚本花费模式下见证脚本的字节数，最终达到降低交易手续费的目的。

![huffman应用](imgs/huffman应用.png)

前文提到，当Taproot按照脚本模式进行花费时，需要提供脚本在MAST中的Proof。如上图，当我们想通过script_A进行花费，见证脚本中需要提供：

- 符合script_A的执行数据D
- script_A
- P
- TaggedHash(B), TaggedHash(C) TaggedHash表示带标签的hash，固定长度32字节，使用带标签的hash目的是减少hash碰撞

 忽略前两项的字节数，可以看出，最后一项的字节数可以表示为 32*(d-1) ，d=3表示 script_A在MAST中的高度。换句话说，最后一项的字节数与脚本在MAST中高度线性相关。因此，对于 script_A, script_B, script_C 三个脚本，我们可以根据脚本使用频率赋予权重，构造哈夫曼树，作为MAST。最终，根据Huffman的特性，使用频率越高的 script , 在哈夫曼树中的高度越低，见证脚本中字节数越少，交易手续费越低。

 总而言之，交易手续费与交易脚本的字节数息息相关。Taproot的聚合签名可以帮助我们有效减少按签名模式花费时的交易脚本字节数，但是利用Huffman构造MAST可以进一步帮助我们减少按脚本模式花费时的交易脚本字节数。

### 3. taproot交易过程

Taproot的核心是由Schnorr 签名和MAST抽象语法树组成，Taproot交易过程本文主要从Taproot公钥的创建和Taproot的花费模式两个方面阐述。

#### **3.1 创建Taproot公钥**

为了创建Taproot公钥，首先需要了解Taproot聚合公钥和聚合签名的产生过程。目前关注度较高的相关研究包括MuSig1和MuSig2。相比于MuSig2两轮通信，MuSig1最大的缺点在于它创建签名需要三轮通信，而每一轮通信都由来回传递的消息组成。由于本文未涉及网络间通信，因此这里主要讨论的是聚合公钥和聚合签名的基本生成过程。

##### **3.1.1 聚合公钥**

![聚合公钥](imgs/聚合公钥.png)

从上图可以看出聚合公钥的生成过程可以分三步：1）相互传递公钥，并对所有公钥拼接进行一次聚合hash，生成c_all。 2）c_all和i的公钥拼接hash后生成因子c_i。 3) 根据因子c_i进行线性组合得到聚合公钥P_agg。

```Bash
privkey1, pubkey1 = generate_key_pair(sha256(b'key0'))
privkey2, pubkey2 = generate_key_pair(sha256(b'key1'))
privkey3, pubkey3 = generate_key_pair(sha256(b'key2'))
pubkey_list = [pubkey1, pubkey2, pubkey3]

# 1) Aggregate hash of all public keys
pubkey_list_sorted = sorted([int.from_bytes(key.get_bytes()[1:], 'big') for key in pubkey_list])
L = b''
for px in pubkey_list_sorted:
    L += px.to_bytes(32, 'big')
Ln = hashlib.sha256(L).digest()

# 2) 3) Calculate the factor and generate the aggregate public key
musig_c = {}
aggregate_key = 0
for key in pubkey_list:
    musig_c[key] = hashlib.sha256(Ln + key.get_bytes()[1:]).digest()
    aggregate_key += key.mul(musig_c[key])
```

##### **3.1.2 聚合签名**

![聚合签名](imgs/聚合签名.png)

聚合签名的生成过程上图显示需要进行三轮通信，主要分成两大步：1）生成nonce并线性聚合生成R_agg。 2）各方利用私钥生成Schnorr签名并进行聚合，得到最终的聚合签名（R_agg, s1+s2+s3）。

```Bash
# 1) generate nonce and aggregate
k1, R1 = generate_key_pair()
k2, R2 = generate_key_pair()
k3, R3 = generate_key_pair()
R_agg, negated = aggregate_schnorr_nonces([R1, R2, R3])

if negated:
    k1.negate()
    k2.negate()
    k3.negate()

msg = sha256(b'msg')

# 2) Aggregate signature
s1 = sign_musig(privkey1*musig_c[pubkey1], k1, R_agg, aggregate_key, msg)
s2 = sign_musig(privkey2*musig_c[pubkey2], k2, R_agg, aggregate_key, msg)
s3 = sign_musig(privkey3*musig_c[pubkey3], k3, R_agg, aggregate_key, msg)
sig = aggregate_musig_signatures([s1, s2, s3], R_agg)

# Verify the correctness of the signature
assert aggregate_key.verify_schnorr(sig, msg)
```

##### **3.1.3 引入MAST抽象语法树**

![引入MAST](imgs/引入MAST.png)

如上图所示，Taproot公钥主要由两部分组成，包括聚合公钥P和MAST结构形成的公钥tG。假设P是Alice,Bob,Charlie的聚合公钥，script_A,script_B,script_C是Alice,Bob,Charlie相关的脚本。那么，Taproot公钥创建过程如下：

- Alice,Bob和Charlie各自生成公私钥。

```Bash
privkey_alice, pubkey_alice = generate_key_pair()
privkey_bob, pubkey_bob = generate_key_pair()
privkey_charlie, pubkey_charlie = generate_key_pair()
```

- 公钥聚合成pubkey_agg，并调整私钥，用于以后的签名。

```Bash
c_map, pubkey_agg = generate_musig_key([pubkey_alice, pubkey_bob, pubkey_charlie])

privkey_alice_c = privkey_alice * c_map[pubkey_alice]
privkey_bob_c = privkey_bob * c_map[pubkey_bob]
privkey_charlie_c = privkey_charlie * c_map[pubkey_charlie]
```

- 创建脚本script_A,script_B,script_C

```Bash
scriptA = CScript([pubkey_alice.get_bytes(), OP_CHECKSIG])
scriptB = CScript([pubkey_bob.get_bytes(), OP_CHECKSIG])
scriptC = CScript([pubkey_charlie.get_bytes(), OP_CHECKSIG])
```

- 构建MAST抽象语法树，计算MAST结构对应的私钥taptweak。上图中TaggedHash表示带标签的hash,固定长度32字节，计算方式是TaggedHash(tag, x) = sha256(sha256(tag) + sha256(tag) + x)；ver表示Tapscript版本号，当前值为0xc0；size表示scirpt的字节数；A&B表示A,B字典排序后按字节拼接。

```Bash
TAPSCRIPT_VER = bytes([0xc0])

# 1) Compute TapLeaves A, B and C
# Method: ser_string(data) is a function which adds compactsize to input data.
hash_inputA = TAPSCRIPT_VER + ser_string(scriptA)
hash_inputB = TAPSCRIPT_VER + ser_string(scriptB)
hash_inputC = TAPSCRIPT_VER + ser_string(scriptC)
taggedhash_leafA = tagged_hash("TapLeaf", hash_inputA)
taggedhash_leafB = tagged_hash("TapLeaf", hash_inputB)
taggedhash_leafC = tagged_hash("TapLeaf", hash_inputC)

# Method: Returns tapbranch hash. Child hashes are lexicographically sorted and then concatenated.
def tapbranch_hash(l, r):
    return tagged_hash("TapBranch", b''.join(sorted([l, r])))

# 2) Compute Internal node TapBranch AB
# Method: use tapbranch_hash() function
internal_nodeAB = tapbranch_hash(taggedhash_leafA, taggedhash_leafB)

# 3) Compute TapTweak
rootABC = tapbranch_hash(internal_nodeAB, taggedhash_leafC)
taptweak = tagged_hash("TapTweak", pubkey_agg.get_bytes() + rootABC)
print("TapTweak:", taptweak.hex())
```

- 根据公式Q=P+tG合成taproot公钥,并生成segwit_address用于下文交易。

```Bash
# generate Taproot pubkey
taptweak_pubkey = pubkey_agg.tweak_add(taptweak)

# generate segwit address
taptweak_pubkey_b = taptweak_pubkey.get_bytes()
taptweak_pubkey_b = bytes([taptweak_pubkey_b[0] & 1]) + taptweak_pubkey_b[1:]
segwit_version = 1
segwit_address = program_to_witness(segwit_version, taptweak_pubkey_b)
print('Segwit address:', segwit_address)
```

- 向Taproot地址转账50个btc

```Bash
# Start node
test = util.TestWrapper()
test.setup()
node = test.nodes[0]

# Generate coins and create an output
tx = node.generate_and_send_coins(segwit_address)
print("Transaction {}, output 0\nsent to {}\n".format(tx.hash, segwit_address))
```

##### **3.1.4 Taproot花费**

为了完成从上述Taproot地址向Bob个人转账0.5个btc,有两种支付途径：一种是Alice，Bob，Charlie都进行签名后形成聚合签名，完成向Bob的转账；另一种是通过MAST结构中的script向Bob进行转账。

- 创建交易原文，填充接受方地址，转账数量等数据。

```Bash
spending_tx=CTransaction()

spending_tx.nVersion =2

spending_tx.nLockTime=0


outpoint = CoutPoint(int(tx.hash，16)，0)
spending_tx_in=CTxIn(outpoint)
spending_tx.vin =[spending tx in]

scriptpubkey =bytes(cscript([op 1, pubkey alice.get bytes()]))


amount_sat=int(0.5*100000000)
dest_output =CTxOut(nValue=amount sat, scriptPubKey=scriptpubkey)
spending_tx.vout =[dest_output]


print("Spending transaction:\n{}".format(spending tx))
Spending transaction:
CTransaction(nVersion=2 vin=[CTxIn(prevout=CoutPoint(hash=102517bf877c74489c83d4b58ala22e067526b79288076afba n=0)scriptSig= nsequence=0)]vout=[CTxOut(nValue=0.50000000 scriptPubKey=7280a8f376ega82ba8e44f1dcf254a8517ae7160f41ea9'73334a)wit=CTxWitness()nLockTime=0)
```

- 按照第一种方式进行转账，首先需要Alice，Bob，Charlie各自生成nonce并进行聚合，然后各自利用私钥进行Schnorr签名，最后进行签名的聚合操作。因此，这种方式最终的见证脚本是一个单独的签名,固定长度64字节。

```Bash
# 生成密钥对和随机数  
k_alice, R_alice = generate_key_pair()  
k_bob, R_bob = generate_key_pair()  
k_charlie, R_charlie = generate_key_pair()  
  
# 聚合随机数  
R_agg, negated = aggregate_schnorr_nonces([R_alice, R_bob, R_charlie])  
  
# 如果聚合后的随机数被拒绝，则反签名  
if negated:  
    k_alice.negate()  
    k_bob.negate()  
    k_charlie.negate()  
  
# 创建sighash  
sighash = TaprootSignatureHash(spending_tx, [tx.vout[0]], SIGHASH_ALL_TAPROOT, input_index=0)  
  
# 单独签名并聚合部分签名  
e = musig_digest(R_agg, taptweak_pubkey, sighash)  
s_alice = sign_musig(privkey_alice_c, k_alice, R_agg, taptweak_pubkey, sighash)  
s_bob = sign_musig(privkey_bob_c, k_bob, R_agg, taptweak_pubkey, sighash)  
s_charlie = sign_musig(privkey_charlie_c, k_charlie, R_agg, taptweak_pubkey, sighash)  
  
# 聚合签名  
sig_agg = aggregate_musig_signatures([s_alice, s_bob, s_charlie, e], R_agg)  
  
# 将聚合签名添加到交易见证中  
spending_tx.wit.vtxinwit.append(CTxInWitness([sig_agg]))
```

- 测试第一种花费组建的交易原文合法并发送交易

```Bash
# Test mempool acceptance  
assert node.test_transaction(spending_tx)  
  
# send transaction  
txid = node.sendrawtransaction(hexstring=str(spending_tx.serialize().hex()), maxfeerate=0)  
print("Success!", txid)
```

- 按照第二种方式进行转账，假设是Alice通过script_A完成向Bob的转账，那么见证脚本需要包括：1）`[Stack element(s) satisfying TapScript_A]` 2）`[TapScript_A]` 3）`[Controlblock c]`。其中`[Controlblock c]`表示的是`TapScript_A`相关的proof,长度为33+32n。33个字节中的首字节是聚合公钥和Taproot版本号共同计算得出，剩下32个字节表示的是聚合公钥的x坐标。32n表示的是`TapScript_A`的proof，在本例中n=2，指的是`taggedhash_leafB`和`taggedhash_leafC`。

```Bash
# 创建TapLeafA的签名哈希  
sighashA = TaprootSignatureHash(spending_tx,   
                                [tx.vout[0]],  
                                SIGHASH_ALL_TAPROOT,  
                                input_index=0,  
                                scriptpath=True,  
                                tapscript=scriptA)  
  
# 使用私钥生成签名  
signatureA = privkey_alice.sign_schnorr(sighashA)  
  
# 打印签名  
print("Signature for TapLeafA: {}\n".format(signatureA.hex()))  
  
# 聚合公钥的字节表示  
pubkey_agg_b = pubkey_agg.get_bytes()  
  
# 创建控制块  
Controlblock = bytes([pubkey_agg_b[0] & 0x01 | 0xc0]) + pubkey_agg_b[1:] + taggedhash_leafB + taggedhash_leafC  
  
# 向交易添加见证  
# 提示：见证栈对于脚本路径 - [满足tapscript的元素] [TapLeaf.script] [controlblock]  
# 提示：tapscript的控制块在control_map[TapLeaf.script]中  
witness_elements = [signatureA, scriptA, Controlblock]  
spending_tx.wit.vtxinwit.append(CTxInWitness(witness_elements))
```

- 测试第二种花费组建的交易原文合法并发送交易

```Bash
# Test mempool acceptance  
assert node.test_transaction(spending_tx)  
  
# send transaction  
txid = node.sendrawtransaction(hexstring=str(spending_tx.serialize().hex()), maxfeerate=0)  
print("Success!", txid)
```

#### **3.2 总结**

总的来看，Taproot交易主要关注的是一种输出和两种花费模式。一种输出使得无论是个人交易还是多签交易，锁定脚本中公钥是一致的，无法从形式上进行区分。两种花费模式使得我们可以用更少的字节，实现更复杂的交易过程。

## 十. BTC 生态项目分析





## 十一.比特币生态知名

- Stacks---->侧链项目
- Nervos---------> 比特币 Layer2
- FBTC----->Function BTC----->FBTC 发布到 Mantle,  FBTC 做 defi 等操作
- Babylon: 为 POS 和 L2 提供安全保障的基础设施，同时也是 BTCFI 的项目，支持 BTC 质押

-------------------------------------------------------------------------------------------------------------------------------------------

- MerlinChain--->侧链项目
- Nubit-----------> 比特币生态 DA
- BitVM-----------> 比特币 Layer2 通用型的技术解决方案
  - BitLayer
- Solv: 比特质押项目，同时也是 BTCFI 的项目，已经死掉
