# 一.内容提要

- call, delegatecall, staticcall 和 multicall 基本使用
- 跨合约的调用方式
- 函数选择器
- create2 底层原理与实现机制
- 合约删除(合约自毁)
- Solidity 内联汇编
- 合约的 lib 库 
- OZ 代码库讲解 
- 基于 OZ 发行第一个 ERC20 代币

# 二. call, delegatecall, staticcall 和 multicall 基本使用

在Solidity中，call、delegatecall、staticcall 和 multicall 是用于合约间交互的四种重要机制。`call` 和 `delegatecall` 是用于执行外部合约调用的低级函数, staticcall 是一种只读调用，用于调用另一个合约的只读函数, `Multicall` 是一种实现，可以一次性执行多个合约调用，减少交易成本和提高效率。

## 1. Call 

![call](imgs/call.png)

### 1.1 Call 的基本使用

- **定义**
  - call 是 Solidity 中最基础的底层函数调用方法。
  - 用于调用另一个合约的方法，可以发送 ETH 并附带数据，前面已经讲过了
- **特性**
  - 调用目标合约的函数，代码在目标合约的上下文中执行
  - 可以附加 ETH（value）
  - 可以调用未知的合约或动态指定调用数据
  - 调用成功与否需要手动检查返回值

### 1.2 代码案例

```TypeScript
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract CallFunction {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }
}

contract CallFunctionImplement {
    function callSetNumber(address _target, uint256 _umber) public {
        (bool success, ) = _target.call(
            abi.encodeWithSignature("setNumber(uint256)", _umber)
        );
        require(success, "call set number fail");
    }

    function callIncrement(address _target) public {
        (bool success, ) = _target.call(
            abi.encodeWithSignature("increment()")
        );
        require(success, "call increment fail");
    }
}
```

以上面的代码为例子，CallFunctionImplement 调用 CallFunction 的函数逻辑，改变的是 CallFunction 合约的状态，并不是改变 CallFunctionImplement 合约的状态，也就是说 call 调用合约就改变被调用合约的状态。

## 2. delegatecall

![delegateCall](imgs/delegateCall.png)

### 2.1 基本使用

- **定义：**delegatecall 是一种特殊的调用方式，用于在当前合约的上下文中执行另一个合约的代码
- **特性**
  - 目标合约的代码在调用合约的上下文中执行（msg.sender 和 msg.value 保持不变）
  - 目标合约的代码操作的是调用合约的存储。
- **适用场景**
  - 实现代理合约（Proxy Contract）
  - 支持合约升级

### 2.2 课堂代码案例

```TypeScript
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract DelegateCallFunction {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }
}

contract DelegateCallFunctionImplement {
    uint256 public number;

    function callSetNumber(address _target, uint256 _umber) public {
        (bool success, ) = _target.delegatecall(
            abi.encodeWithSignature("setNumber(uint256)", _umber)
        );
        require(success, "call set number fail");
    }

    function callIncrement(address _target) public {
        (bool success, ) = _target.delegatecall(
            abi.encodeWithSignature("increment()")
        );
        require(success, "call increment fail");
    }
}
```

## 3. Staticcall 的使用

### 3.1 基本使用

- 定义
  - staticcall 是一种只读调用，用于调用另一个合约的只读函数
  - 引入于 Solidity 0.4.21，用于防止调用中对状态进行修改
- 特性
  - 只读：无法在调用中更改状态变量
  - 安全性：确保调用的函数不会意外修改状态
  - 用途：适用于需要执行计算或获取数据但不希望更改状态的场景

## 4. Multicall 的使用

- 课程代码案例

```TypeScript
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { console} from "forge-std/Test.sol";

contract TargetContract {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }
}

contract TargetContractOne {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }
}


contract MultiCall {
    struct Call {
        address targetAddress;
        bytes callData;
    }

    // 最重要的问题，无限 for 循环可能存在
    // - gas 消耗很大
    // - 区块链区块大小是有现在，不懂的用户 calls 传得很多，会撑破区块
    function multicall(Call[] memory calls) public {
        for(uint256 i = 0; i < calls.length; i++) {
            (bool success, ) = calls[i].targetAddress.call(calls[i].callData);
            require(success, "call item failed");
        }
    }
}


contract MultiCaller {
    MultiCall public multiCall;

    constructor(address _multiCall){
        multiCall = MultiCall(_multiCall);
    }

    function setNumbers(address target, uint256 number, address targetOne, uint256 numberOne) public {
        console.log("target==", target);
        console.log("data==", number);
        console.log("targetOne==", targetOne);
        console.log("dataOne==", numberOne);

        MultiCall.Call[] memory calls = new MultiCall.Call[](2);

        calls[0] = MultiCall.Call({
            targetAddress: target,
            callData: abi.encodeWithSignature("setNumber(uint256)", number)
        });

        calls[1] = MultiCall.Call({
            targetAddress: targetOne,
            callData: abi.encodeWithSignature("setNumber(uint256)", numberOne)
        });

        multiCall.multicall(calls);

    }
}
```

# 三.常见的 address(this)，tx.origin 和 msg.sender 语句解释

- *address(this): 当前合约地址，若我在 CommonUse 里面使用，address(this) 代表的就是 CommonUse 合约地*
- *tx.origin: 合约调用的源地址*
- *msg.sender: 合约的调用者*
- *msg.value: 合约调用者要转入合约的 NativeToken 的数量*
- *msg.data: 合约的调用者携带的 data*
- *block.number: 合约部署所在链最新区块高度*
- *block.gasLimit: 合约部署所在链最新区块 gasLimit*
- *block.timestamp: 合约部署所在链最新区块 timestamp*
- *tx.gasprice: 合约当前交易的 gasprice*

## 1. 图解 *tx.origin，msg.sender 和  address(this)*

![全局变量](imgs/全局变量.png)