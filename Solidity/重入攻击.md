## 重入攻击

### 1. 历史上发生重入攻击项目

| 项目/事件名称                     | 发生时间 | 损失金额                  | 被攻击逻辑摘要                                               |
| :-------------------------------- | :------- | :------------------------ | :----------------------------------------------------------- |
| **The DAO**                       | 2016年   | 360万 ETH（约5000万美元） | 在更新用户余额之前，将ETH发送给调用者，允许递归提款。        |
| **Synthetix**                     | 2019年   | 370万枚 sETH              | 合约在更新用户余额之前进行外部调用，导致余额状态未被及时更新。 |
| **[Lendf.Me](https://lendf.me/)** | 2020年   | 2500万美元                | 在更新内部状态之前进行外部调用，被攻击合约递归提款。         |
| **CREAM FINANCE**                 | 2021年   | 1880万美元                | 重入漏洞允许利用者进行第二次借贷，在首次借贷未完成时再次进行借贷操作。 |
| **Fei Protocol**                  | 2022年   | 8000万美元                | 使用了包含重入漏洞的第三方代码，在资金转移前未正确更新状态。 |

### 2. 攻击原理与POC

重入攻击的核心漏洞在于：**合约在进行外部调用之前，没有更新自身的内部状态**。攻击者利用这个漏洞，在接收ETH的 `fallback` 函数（或者 `receive` 函数）中递归地调用受害合约的提款函数，从而多次通过余额检查，在余额被清零前提取远超其实际存款的金额。

- **单个函数重入**：攻击针对同一个函数进行递归调用。关键问题在于合约在向攻击者发送ETH后，才更新发送者的余额为0。在这期间，攻击者的合约在 `fallback` 函数中再次调用提款函数，由于余额尚未清零，可以再次通过检查并获取ETH，形成循环，直到合约余额几乎被耗尽。
- **跨函数重入**：攻击者利用共享相同状态的多个函数进行攻击。例如，在提款函数中发送ETH后、但尚未更新余额前，攻击者的 `fallback` 函数调用受害合约的转账函数，将自己的余额转给另一个地址。由于提款函数尚未更新余额，转账函数依然认为攻击者有足够的余额。

下面是一个典型的重入攻击案例的简化POC（Proof of Concept）代码逻辑：

**1. 存在漏洞的银行合约（Victim Contract）:**

solidity

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VulnerableBank {
    mapping (address => uint) public userBalances;

    function withdraw() public {
        uint amount = userBalances[msg.sender];
        require(amount > 0, "Insufficient balance");
        // 漏洞：先进行外部调用发送ETH，然后才更新状态
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        userBalances[msg.sender] = 0; // 状态更新发生在外部调用之后
    }
}
```



**2. 攻击者合约（Attacker Contract）:**

solidity

```
contract Attacker {
    VulnerableBank public targetBank;

    constructor(address _bankAddress) {
        targetBank = VulnerableBank(_bankAddress);
    }

    // 攻击入口函数
    function attack() external payable {
        // 先存入一些ETH以通过余额检查
        targetBank.deposit{value: msg.value}();
        // 然后发起提款，开始攻击
        targetBank.withdraw();
    }

    // 当收到VulnerableBank发送的ETH时，此函数会被触发
    fallback() external payable {
        // 如果目标银行还有足够的余额，就再次调用其withdraw函数
        if (address(targetBank).balance >= msg.value) {
            targetBank.withdraw();
        }
    }
}
```



**攻击流程图解：**

1. 攻击者调用 `attack()` 函数，向 `VulnerableBank` 存入1 ETH。
2. `attack()` 随即调用 `VulnerableBank` 的 `withdraw()` 函数。
3. `VulnerableBank` 检查到攻击者有1 ETH余额，然后尝试向 `Attacker` 合约发送1 ETH。
4. 发送ETH这一操作，会触发 `Attacker` 合约的 `fallback()` 函数。
5. 在 `fallback()` 函数中，`Attacker` 合约再次调用 `VulnerableBank` 的 `withdraw()` 函数。
6. **关键点**：此时，`VulnerableBank` 还未将攻击者的余额清零（因为发生在 `require(success, "Transfer failed")` 之后），所以第二次的 `withdraw()` 调用依然能通过 `require(amount > 0, "Insufficient balance")` 检查。
7. 循环从步骤3开始重复，`VulnerableBank` 再次向 `Attacker` 发送1 ETH，并再次触发 `fallback`......
8. 这个递归循环会持续进行，直到 `VulnerableBank` 的合约余额不足以完成下一次转账，或者达到Gas限制，攻击停止。最终，攻击者成功提取了远多于其存款的ETH。

### 3. 主要防御方法

要有效防范重入攻击，可以采用以下几种经过实践检验的方法：

1. **遵循“检查-效果-交互”模式（Checks-Effects-Interactions）**
   这是最推荐且最基础的原则。编写函数时：

   - **检查（Checks）**：首先进行所有必要的条件验证（如 `require(balance > 0)`）。
   - **效果（Effects）**：接着更新合约的所有状态变量（如 `balances[msg.sender] = 0`）。
   - **交互（Interactions）**：最后再与其他合约或外部地址进行交互（如 `msg.sender.call{value: amount}("")`）。
     将上述漏洞合约的 `withdraw` 函数修改为：

   solidity

   ```
   function withdraw() public {
       uint amount = userBalances[msg.sender];
       require(amount > 0, "Insufficient balance");
       // 效果：先更新状态
       userBalances[msg.sender] = 0;
       // 交互：然后进行外部调用
       (bool success, ) = msg.sender.call{value: amount}("");
       require(success, "Transfer failed");
   }
   ```

   

   这样，即使攻击者尝试重入，他们的余额也早已被清零，无法通过第二次的余额检查。

2. **使用重入锁（Reentrancy Guard）**
   这是一种互斥锁机制，防止函数在未执行完毕时被再次进入。OpenZeppelin库提供了现成的 `ReentrancyGuard` 合约。

   solidity

   ```
   import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
   contract SecureBank is ReentrancyGuard {
       function withdraw() public nonReentrant {
           // ... 函数逻辑
       }
   }
   ```

   

   修饰器 `nonReentrant` 会在函数执行期间"加锁"，阻止任何重入调用。
