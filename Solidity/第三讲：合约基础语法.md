# 一.内容提要

- 数据类型
- 循环分之
- 合约函数
- 合约事件
- 抽象合约与接口
- 异常处理
- 变量作用域和数据存储 
- Solidity 内存布局 

# 二.智能合约的数据类型

## 1. 数据类型概览

![智能合约数据类型](imgs/智能合约数据类型.png)

## 2. 值类型和引用类型的区别

值类型：是指直接存储在合约里面的状态变量或者函数栈中数据类型，与引用类型不一样的是值类型赋值和传递的过程通过复制整个数据对象的值进行的，而不是引用或者指针。

引用类型：引用类型是一种特殊的数据类型，用于存储复杂的数据结构或者允许通过引用传递数据类型，与值类型不一样的是，引用类型的赋值和传递是通用引用或者指针进行的，在内存中是通引用地址来操作。

| 特性         | 值类型              | 引用类型                           |
| :----------- | :------------------ | :--------------------------------- |
| **存储方式** | 直接存储值          | 存储引用（指针）                   |
| **赋值行为** | 复制整个值          | 共享引用                           |
| **修改影响** | 不影响原始值        | 可能影响原始值                     |
| **数据位置** | 不需要指定          | 必须指定 (memory/storage/calldata) |
| **Gas 消耗** | 通常较低            | 通常较高                           |
| **示例**     | uint, bool, address | array, struct, mapping             |

## 3. 逻辑运算符

### 3.1 逻辑运算符

- 逻辑与 `&&`
- 逻辑或 `||`
- 逻辑非`!`

和其他语言是一样的，`&&` 和 `||` 运算遵循短路原则

### 3.2 数学运算

```
+， -， *, /, mod, = !=
```

### 3.3 位运算

移位与 `&`

移位或 `｜`

## 4. 值类型

### 4.1 Bool 类型

- Bool 数据类型的定义

```Plain
bool 修饰 变量名
bool public isActive
```

- 初始化变量

```Plain
bool public isActive = true/false
```

- 布尔值在逻辑运算符里面的使用

```Plain
bool a = true
bool b = false

//  a 是 true 需要判断 b， b 是 false，返回 false; 
bool retAndOne= a && b // false  
//  b 是 false, 直接返回 false, 不再去计算 b 是; 
bool retAndTwo =  b && a // false 

//  a 是 true 直接返回 true, 不在做 b 的运算; 
bool retOr = a || b // true
//  b 是 false, 计算 a 之后，a true 返回 true
bool retOr = b || a // true

bool retNotA = !a // false
bool retNotB = !b // true
```

#### 代码案例

- https://github.com/the-web3-contracts/basic-evm-contracts/tree/main/data-type

### 4.2 整形

在 solidity 中，整形用于表示整数，支持有符号和无符号类型,  整形支持数算运算符和移位运算符的计算

#### 4.2.1 无符号类型

无符号表示的是非负整数，关键字 `uint`, 宽度从 `uint8` 到 `uint256` , 中间加 8 位（例如 `uint8, uint16, uint32 ... uint256`）, 如果定义的 `uint`, 默认是 `uint256`。

```Plain
uint + 位数  修饰符  变量名字

uint256 public a
uint32 public b
uint16 public c
uint8 public d
```

#### 4.2.1 有符号类型

有符号类型表示正负数，关键字 `int` , 宽度从 `int8` 到 `int256` , 中间加 8 位, 例如 `int8, int16, uint32 ... int256`）, 如果定义的 `int`, 默认是 `int256`。

```Plain
int + 位数  修饰符  变量名字

int256 public a
int32 public b
int16 public c
int8 public d
```

#### 4.2.2 溢出和下溢

在 solidty 早期版本，指的是 0.8.0 之前的版本，整数的溢出是一个常见的问题，需要人为处理这个问题，如果你项目还在使用 0.8.0 之前的版本，需要使用别人封住好的 SafeMath 库;  在 0.8.0 之后的版本里面，智能合约内部把这个问题解决了。

```Plain
pragma solidity ^0.8.0;

contract OverflowExample {
    uint8 public maxUint8 = 255;

    function increment() public {
        maxUint8 += 1; // 这将导致运行时错误，因为 uint8 的最大值是 255
    }
}
```

- Uniswap V2 的 SafeMath 库

```JavaScript
library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}
```

#### 4.2.3 常用的整型运算符包括：

- 比较运算符（返回布尔值）： `<=`， `<`，`==`， `!=`， `>=`， `>`
- 算数运算符： `+`， `-`， `*`， `/`， `%`（取余），`**`（幂）

#### 代码案例

- https://github.com/the-web3-contracts/basic-evm-contracts/tree/main/data-type

### 4.3 地址类型

在 Solidity 中，地址类型 (`address`) 是一种特殊的数据类型，用于存储 Ethereum 地址。一个 Ethereum 地址是一个 20 字节（160 位）的值，通常用于表示账户（包括外部账户和合约账户）。地址类型有一些特定的功能和方法，允许开发者与区块链上的账户进行交互。

#### 4.3.1 地址的声明与初始化

- 地址声明方式

```Plain
address 修饰符 变量名字

address public reciptant
```

- 声明并初始化

```Plain
address public reciptant = address(0);

address public sender = 0x45Bd8ea16cFEB0D937a2D98cBEb0300e3E689Fe7
```

#### 4.3.2 地址特定的方法

- 获取 balance

```Plain
address public sender = 0x45Bd8ea16cFEB0D937a2D98cBEb0300e3E689Fe7
uint256 balance = sender.balance;
```

- `address` 与 `address payable`, 在 Solidity 中，`address` 类型的变量不能接收或发送 Ether。如果需要进行这些操作，需要使用 `address payable` 类型。

```Plain
address payable public reciptant = 0x45Bd8ea16cFEB0D937a2D98cBEb0300e3E689Fe7
```

- 发送 ETH

```Plain
payable(reciptant).transfer(1 ether);

bool success = recipient.send(1 ether);
require(success, "Transfer failed");

(bool success, ) = recipient.call{value: 1 ether}("");
require(success, "Transfer failed");
```

- 面试重点

| 对比项     | call                                   | transfer                           | send                               |
| ---------- | -------------------------------------- | ---------------------------------- | ---------------------------------- |
| 本质       | 低层次的消息调用（message call）       | 原生的方法和 balance 类似          | send 是一个 基于 call 的封装       |
| 用途       | 调用合约函数（可带 data、value）       | 向地址转账（只发 ETH，不调用函数） | 向地址转账（只发 ETH，不调用函数） |
| 返回值     | 返回 (bool success, bytes memory data) | 没有返回                           | 返回 bool success                  |
| Gas 限制   | 可以自定义 gas                         | 固定只提供 2300 gas                | 固定只提供 2300 gas                |
| 调用失败时 | 不会自动 revert，需手动处理            | 会自动 revert, 不需要手动处理      | 不会自动 revert，返回 false        |
| 常见用途   | 调用外部合约函数或执行低层操作         | 安全发送 ETH                       | 安全地发送 ETH，不影响主逻辑       |